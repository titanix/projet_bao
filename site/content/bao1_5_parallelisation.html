<div id="content">
<div id='main' class="book">
    <h1>Parallélisation du code</h1>
  <div>
  <h2>...</h2>
<p>
</p>

<p>Le programme repose sur le traitement d'un grand nombre de fichiers XML, qui peuvent
mettre du temps à être chargé en mémoire, et le traitement de ce format de données est
gourmant en temps CPU.</p>

<p>Comme le temps de traitement de mes fichiers était très long (notamment à cause du fait
que je traitais des fichiers énorme qui ne devait pas être inclus), j'ai décidé de tenter
de paralléliser le code afin de réduire le temps d'exécution.</p>


<div class="note-block">
<div class="note-block-header">
	<span style="font-weight:bold;">Note</bold>
</div>
<div class="note-block-content">
Je casse le suspens tout de suite : ça n'a pas marché.<br/>Ceci étant j'ai appris 
et essayé plusieurs choses que je vais lister sur cette page.
</div>
</div>

<p>
Comme l'interpréteur Perl est au moins aussi mauvais que le langage qu'il interprète,
il ne s'arrange donc pas pour exploiter de lui-même plusieurs CPU ou cores,
comme le ferait par machine BEAM (la VM d'Erlang) par exemple.
<br/>Il faut donc le faire explicitement. Dans la plupart des langages, on penserait
pour cela à utiliser des threads (aussi appelés processus légers). Et c'est faisable
en Perl aussi, mais en me renseignant sur le sujet, je suis tout d'abord tombé sur
la création de nouveaux processus, au moyen de fork.
</p>


<p>La méthode que j'ai utilisée fait usage de la classe Parallel:ForkManager, qui n'est
qu'un wrapper autour de l'appel système fork. Les processus créés utilisent de facto des 
espaces mémoires différents pour l'écriture (il est fait usage de la technique de copy
on write par le système, d'où un faible coût de création des processus) ce qui empêchent
de les faire travailler sur une même structure de données.
Un premier coût est donc la sérialisation et la désérialisation dans un fichier pour
passer les résultats au processus père.</p>

<p>Ceci dit, j'ai pû remarquer expérimentalement que ce coût était négligeable dans
notre cas, en comparant les tas d'exécution entre des exécutions qui utilise le dossier
temporaire utilisé pour la sérialisation est présent sur le disque dur et d'autres où 
il s'agit d'un emplacement situé sur un ramdisk.</p>

<h2>Partition de l'ensemble des données</h2>

<p>Afin de nourrir les différents processus, il est nécessaire au préalable de 
partitionner l'ensemble des données à traiter en N parts qu'on essaiera de faire les
plus égales possibles.</p>

<p>Pour cela j'ai crée un version particulière du parcours de l'arborescence dont laquelle
il existe une fonction qui va se charger construire une liste de répertoires. Il est 
possible de choisir la profondeur à laquelle descend la procédure pour établir la liste.
<br/>Dans le cas de nos données, une profondeur de 1 construit la liste des dossiers
qui correspondent aux mois de l'année</p>

<p>Le code itère ensuite sur cette liste et crée un processus par dossier. Le composant
ForkManager se charge de respecter la contrainte qui lui ai passé en paramètre du nombre
maximal de processus fils concurrent.</p>






<p>Le second coût est celui de réunir les différentes données dans une seule liste. Faire
cela permet d'utiliser une procédure unique d'écriture dans les fichiers de sortie. Mais
cela prend beaucoup trop de temps.</p>



size of hash:  12.
taille de la liste:  22542.
taille de la liste:  25809.
taille de la liste:  24174.
taille de la liste:  26010.
taille de la liste:  24276.
taille de la liste:  26010.
taille de la liste:  26877.
taille de la liste:  24075.
taille de la liste:  24593.
taille de la liste:  26010.
taille de la liste:  23724.
taille de la liste:  25998.

On a donc environ 25000 * 12 = 300000 fichiers traités

VS

taille de la liste:  300098.




<p>
Une des difficultés de parallélisation du programme vient du manque de structures
de données thread safe (et lock free tant qu'à faire) dans le langage ou dans sa
bibliothèque standard.
</p>

<div class="code-block">
<div class="code-block-header">
	<span style="font-weight:bold;"></bold>
</div>
<div class="code-block-content">

</div>
</div>



<div id="nav"><a href="">précédent</a> | 
<a href="">suivant</a></div></div>
</div>
</div>